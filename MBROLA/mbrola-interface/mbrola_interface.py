"""
MBROLA Python interface — zero‑dependency wrapper (+ demo)

Features
- Call the `mbrola` binary from Python with a given voice database
- Accept raw .pho content or generate it from text via espeak‑ng (optional)
- Save directly to .wav / .au / .aiff depending on output filename extension
- Control volume, time and pitch ratios (-v, -t, -f)
- Read voice metadata (mbrola -i)
- CLI with --demo, --play and --dump-pho

Requirements
- MBROLA installed and in PATH (or supply absolute path)
- At least one MBROLA voice database (e.g. /usr/share/mbrola/en1/en1)
- Optional: espeak‑ng in PATH to turn text → MBROLA phonemes

Usage
-----
Basic (from text using espeak‑ng):
    from mbrola_interface import MBROLA
    tts = MBROLA(voice_path="/usr/share/mbrola/en1/en1")
    tts.synthesize_text("Hello world", out_path="hello.wav", espeak_voice="mb-en1")

From raw .pho content (string):
    pho = '''
    _ 150
    h 70
    @ 60
    l 80
    o 120  0 110  60 110
    w 80
    3:U 140  0 110  80 100
    r 60
    l 80
    d 80
    _ 150
    '''.strip()
    MBROLA(voice_path="/usr/share/mbrola/en1/en1").synthesize_pho(pho, out_path="hello.wav")

Command‑line:
    python mbrola_interface.py \
        --voice /usr/share/mbrola/en1/en1 \
        --text "Hello from MBROLA" \
        --out hello.wav \
        --espeak-voice mb-en1
"""
from __future__ import annotations

import os
import shlex
import subprocess
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import Optional, Sequence


class MBROLAError(RuntimeError):
    pass


def _which(prog: str) -> Optional[str]:
    """Return absolute path of executable in PATH (or None)."""
    from shutil import which
    return which(prog)


def _ensure_executable(path: Optional[str], fallback: str) -> str:
    """Return a valid executable path, checking PATH if needed."""
    if path:
        p = Path(path)
        if p.is_file() and os.access(p, os.X_OK):
            return str(p)
        raise MBROLAError(f"Executable not found or not executable: {path}")
    w = _which(fallback)
    if not w:
        raise MBROLAError(
            f"Required executable '{fallback}' not found in PATH. Set explicit path or adjust PATH.")
    return w


def _resolve_voice_file(voice_path: str | os.PathLike[str]) -> str:
    """Return the path to the MBROLA voice *file*.

    The argument may be a file like '/usr/share/mbrola/en1/en1' or a directory
    like '/usr/share/mbrola/en1'. If a directory is given, we try sensible
    candidates inside it (same basename as directory, or a single file without
    extension).
    """
    p = Path(voice_path)
    if p.is_file():
        return str(p)
    if not p.exists():
        raise MBROLAError(f"Voice path does not exist: {voice_path}")
    if p.is_dir():
        # candidate 1: file with same basename as directory
        cand = p / p.name
        if cand.exists() and cand.is_file():
            return str(cand)
        # candidate 2: first regular file with no extension
        noext = [f for f in p.iterdir() if f.is_file() and f.suffix == ""]
        if len(noext) == 1:
            return str(noext[0])
        # candidate 3: any regular file (fall back to longest name)
        files = [f for f in p.iterdir() if f.is_file()]
        if files:
            files.sort(key=lambda x: len(x.name), reverse=True)
            return str(files[0])
    raise MBROLAError(f"Could not locate voice file inside: {voice_path}")


def play_audio(path: str) -> bool:
    """Best‑effort audio playback using common CLIs; returns True if one worked.
    Tries: ffplay (ffmpeg), aplay (ALSA), paplay (PulseAudio), afplay (macOS), play (SoX).
    """
    candidates = [
        ("ffplay", ["-autoexit", "-nodisp"]),
        ("aplay", []),
        ("paplay", []),
        ("afplay", []),
        ("play", [])
    ]
    for prog, extra in candidates:
        exe = _which(prog)
        if exe:
            try:
                subprocess.run([exe] + extra + [path], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                return True
            except Exception:
                continue
    return False


@dataclass
class MBROLA:
    voice_path: str
    mbrola_bin: Optional[str] = None

    def __post_init__(self) -> None:
        self.mbrola_bin = _ensure_executable(self.mbrola_bin, "mbrola")
        self.voice_file = _resolve_voice_file(self.voice_path)

    # --- helpers -----------------------------------------------------
    def generate_pho(
        self,
        text: str,
        *,
        espeak_voice: str,
        espeak_bin: Optional[str] = None,
        espeak_extra_args: Optional[Sequence[str]] = None,
    ) -> str:
        """Return MBROLA .pho string generated by espeak‑ng for *text*."""
        espeak = _ensure_executable(espeak_bin, "espeak-ng")
        cmd = [espeak, "-q", "--pho", "-v", espeak_voice]
        if espeak_extra_args:
            cmd += list(espeak_extra_args)
        try:
            gen = subprocess.run(
                cmd,
                input=text.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=False,
            )
        except FileNotFoundError as e:
            raise MBROLAError(f"Failed to execute espeak-ng: {e}") from e
        if gen.returncode != 0:
            raise MBROLAError(
                "espeak-ng failed (exit code %s) with command:\n%s\nStderr:\n%s"
                % (gen.returncode, " ".join(shlex.quote(c) for c in cmd), gen.stderr.decode(errors="ignore"))
            )
        pho = gen.stdout.decode("utf-8", errors="ignore")
        if not pho.strip():
            raise MBROLAError("espeak-ng produced empty .pho stream")
        return pho

    # --- public API -----------------------------------------------------
    def synthesize_pho(
        self,
        pho_text: str,
        out_path: str | os.PathLike[str],
        *,
        volume: float | None = None,
        time_ratio: float | None = None,
        freq_ratio: float | None = None,
        ignore_errors: bool = True,
        comment_char: Optional[str] = None,
    ) -> str:
        """Synthesize audio from MBROLA .pho content and write it to *out_path*.

        The output format is chosen from the filename extension ('.wav', '.au', '.aiff', '.raw').
        Returns the absolute path to the written file.
        """
        out_path = str(Path(out_path).expanduser().resolve())
        cmd = [self.mbrola_bin]
        if ignore_errors:
            cmd.append("-e")
        if comment_char:
            cmd += ["-c", comment_char]
        if volume is not None:
            cmd += ["-v", str(float(volume))]
        if freq_ratio is not None:
            cmd += ["-f", str(float(freq_ratio))]
        if time_ratio is not None:
            cmd += ["-t", str(float(time_ratio))]
        cmd += [self.voice_file, "-", out_path]

        # Use stdin to supply .pho content
        try:
            proc = subprocess.run(
                cmd,
                input=pho_text.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=False,
            )
        except FileNotFoundError as e:
            raise MBROLAError(f"Failed to execute mbrola: {e}") from e

        if proc.returncode != 0:
            raise MBROLAError(
                "MBROLA failed (exit code %s) with command:\n%s\nStderr:\n%s"
                % (proc.returncode, " ".join(shlex.quote(c) for c in cmd), proc.stderr.decode(errors="ignore"))
            )
        return out_path

    def synthesize_text(
        self,
        text: str,
        out_path: str | os.PathLike[str],
        *,
        espeak_voice: str,
        espeak_bin: Optional[str] = None,
        espeak_extra_args: Optional[Sequence[str]] = None,
        **synth_kwargs,
    ) -> str:
        """Generate MBROLA .pho with espeak‑ng and synthesize to *out_path*."""
        pho = self.generate_pho(
            text,
            espeak_voice=espeak_voice,
            espeak_bin=espeak_bin,
            espeak_extra_args=espeak_extra_args,
        )
        return self.synthesize_pho(pho, out_path, **synth_kwargs)

    def synthesize_pho_to_bytes(
        self,
        pho_text: str,
        *,
        suffix: str = ".wav",
        **synth_kwargs,
    ) -> bytes:
        """Synthesize to a temporary file and return its bytes.
        Useful when you want a WAV/AIFF payload in memory.
        """
        with tempfile.TemporaryDirectory() as td:
            out = Path(td) / ("mbrola_out" + suffix)
            self.synthesize_pho(pho_text, out, **synth_kwargs)
            return Path(out).read_bytes()

    def voice_info(self) -> str:
        """Return `mbrola -i <voice>` output (if available)."""
        cmd = [self.mbrola_bin, "-i", self.voice_file, "-", "-"]
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=False)
        return proc.stdout.decode(errors="ignore")


def launch_gui(
    *,
    initial_voice: Optional[str] = None,
    initial_mbrola_bin: Optional[str] = None,
    initial_espeak_voice: Optional[str] = None,
    initial_out: Optional[str] = None,
) -> None:
    """Launch a Tkinter GUI for the MBROLA interface."""

    try:
        import tkinter as tk
        from tkinter import filedialog, messagebox, ttk
    except ImportError as exc:  # pragma: no cover - tkinter may be missing on some platforms
        raise MBROLAError("Tkinter is not available in this Python installation") from exc

    import queue
    import threading

    class MBROLAGUI(tk.Tk):
        def __init__(self) -> None:
            super().__init__()
            self.title("MBROLA Studio")
            self.geometry("960x640")
            self.minsize(820, 560)

            self.task_queue: "queue.Queue[tuple[str, ...]]" = queue.Queue()
            self._build_variables()
            self._configure_style()
            self._build_layout()
            self._update_mode_state()
            self._set_running(False)
            self.after(150, self._poll_queue)

        # ---- widget construction -------------------------------------------------
        def _build_variables(self) -> None:
            self.voice_var = tk.StringVar(value=(initial_voice or ""))
            self.out_var = tk.StringVar(value=(initial_out or ""))
            self.mbrola_bin_var = tk.StringVar(value=(initial_mbrola_bin or ""))
            self.espeak_voice_var = tk.StringVar(value=(initial_espeak_voice or "mb-en1"))
            self.espeak_bin_var = tk.StringVar()
            self.espeak_args_var = tk.StringVar()
            self.mode_var = tk.StringVar(value="text")
            self.demo_text_var = tk.StringVar(value="Hello from MBROLA")
            self.pho_path_var = tk.StringVar()
            self.volume_var = tk.StringVar()
            self.time_ratio_var = tk.StringVar()
            self.freq_ratio_var = tk.StringVar()
            self.comment_char_var = tk.StringVar()
            self.dump_pho_var = tk.StringVar()
            self.ignore_errors_var = tk.BooleanVar(value=True)
            self.play_after_var = tk.BooleanVar(value=False)
            self.status_var = tk.StringVar(value="Ready to create audio.")
            self.last_output: Optional[str] = None

        def _configure_style(self) -> None:
            style = ttk.Style(self)
            current_theme = style.theme_use()
            for theme in ("aqua", "clam", current_theme):
                if theme in style.theme_names():
                    try:
                        style.theme_use(theme)
                        break
                    except tk.TclError:
                        continue

            surface_bg = "#F5F5F7"
            card_bg = "#FFFFFF"

            self.configure(background=surface_bg)

            style.configure("Surface.TFrame", background=surface_bg)
            style.configure("Card.TFrame", background=card_bg, relief="flat", borderwidth=0)
            style.configure("CardInner.TFrame", background=card_bg, relief="flat", borderwidth=0)

            style.configure("TLabel", background=surface_bg, font=("SF Pro Text", 12))
            style.configure("Heading.TLabel", background=surface_bg, font=("SF Pro Display", 20, "bold"))
            style.configure("Subheading.TLabel", background=surface_bg, font=("SF Pro Text", 12))
            style.configure("CardHeading.TLabel", background=card_bg, font=("SF Pro Text", 14, "bold"))
            style.configure("Card.TLabel", background=card_bg, font=("SF Pro Text", 12))
            style.configure("Caption.TLabel", background=card_bg, foreground="#6c6d70", font=("SF Pro Text", 10))
            style.configure("Status.TLabel", background=surface_bg, foreground="#3a3a3c", font=("SF Pro Text", 11))

            style.configure("Accent.TButton", font=("SF Pro Text", 12, "bold"), padding=(18, 10))
            style.map("Accent.TButton",
                      background=[("active", "#005BBB"), ("!disabled", "#007AFF")],
                      foreground=[("!disabled", "#FFFFFF")])
            style.configure("Secondary.TButton", font=("SF Pro Text", 12), padding=(16, 10))
            style.map("Secondary.TButton",
                      background=[("active", "#d1d1d6"), ("!disabled", "#E5E5EA")],
                      foreground=[("!disabled", "#1c1c1e")])

            style.configure("TCheckbutton", background=card_bg, font=("SF Pro Text", 12))
            style.configure("TEntry", padding=6)
            style.configure("TNotebook", background=card_bg, padding=0)
            style.configure("TNotebook.Tab", padding=(16, 8), font=("SF Pro Text", 12), background=surface_bg)
            style.map("TNotebook.Tab",
                       background=[("selected", card_bg), ("!selected", surface_bg)],
                       foreground=[("selected", "#1c1c1e"), ("!selected", "#636366")])

            self.surface_bg = surface_bg
            self.card_bg = card_bg

        def _build_layout(self) -> None:
            container = ttk.Frame(self, padding=24, style="Surface.TFrame")
            container.grid(row=0, column=0, sticky="nsew")
            self.columnconfigure(0, weight=1)
            self.rowconfigure(0, weight=1)
            container.columnconfigure(0, weight=1)
            container.rowconfigure(3, weight=1)

            header = ttk.Frame(container, style="Surface.TFrame")
            header.grid(row=0, column=0, sticky="ew")
            header.columnconfigure(0, weight=1)
            ttk.Label(header, text="MBROLA Studio", style="Heading.TLabel").grid(row=0, column=0, sticky="w")
            ttk.Label(header, text="Design polished voices with a calm, focused workspace.", style="Subheading.TLabel").grid(row=1, column=0, sticky="w", pady=(4, 16))

            voice_card = ttk.Frame(container, padding=18, style="Card.TFrame")
            voice_card.grid(row=1, column=0, sticky="ew")
            voice_card.columnconfigure(1, weight=1)
            ttk.Label(voice_card, text="Voice", style="CardHeading.TLabel").grid(row=0, column=0, columnspan=3, sticky="w")
            ttk.Label(voice_card, text="Point to a MBROLA voice directory or the voice file itself.", style="Caption.TLabel").grid(row=1, column=0, columnspan=3, sticky="w", pady=(2, 12))

            ttk.Label(voice_card, text="Voice path", style="Card.TLabel").grid(row=2, column=0, sticky="w")
            ttk.Entry(voice_card, textvariable=self.voice_var).grid(row=2, column=1, sticky="ew", padx=(0, 12))
            ttk.Button(voice_card, text="Browse…", command=self._browse_voice_file, style="Secondary.TButton").grid(row=2, column=2, sticky="ew")

            ttk.Label(voice_card, text="Voice folder", style="Card.TLabel").grid(row=3, column=0, sticky="w", pady=(8, 0))
            ttk.Label(voice_card, text="If unsure, pick the folder that contains the voice file.", style="Caption.TLabel").grid(row=4, column=0, columnspan=3, sticky="w")
            ttk.Button(voice_card, text="Choose folder…", command=self._browse_voice_dir, style="Secondary.TButton").grid(row=5, column=0, sticky="w", pady=(4, 0))

            ttk.Label(voice_card, text="MBROLA binary", style="Card.TLabel").grid(row=6, column=0, sticky="w", pady=(12, 0))
            ttk.Entry(voice_card, textvariable=self.mbrola_bin_var).grid(row=6, column=1, sticky="ew", padx=(0, 12))
            ttk.Button(voice_card, text="Browse…", command=self._browse_mbrola_bin, style="Secondary.TButton").grid(row=6, column=2, sticky="ew")

            ttk.Label(voice_card, text="Output file", style="Card.TLabel").grid(row=7, column=0, sticky="w", pady=(12, 0))
            ttk.Entry(voice_card, textvariable=self.out_var).grid(row=7, column=1, sticky="ew", padx=(0, 12))
            ttk.Button(voice_card, text="Save as…", command=self._browse_output, style="Secondary.TButton").grid(row=7, column=2, sticky="ew")

            ttk.Separator(container).grid(row=2, column=0, sticky="ew", pady=(24, 0))

            input_card = ttk.Frame(container, padding=18, style="Card.TFrame")
            input_card.grid(row=3, column=0, sticky="nsew", pady=(24, 0))
            input_card.columnconfigure(0, weight=1)
            input_card.rowconfigure(1, weight=1)
            ttk.Label(input_card, text="Input", style="CardHeading.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 8))

            self.input_notebook = ttk.Notebook(input_card)
            self.input_notebook.grid(row=1, column=0, sticky="nsew")

            text_tab = ttk.Frame(self.input_notebook, padding=12, style="CardInner.TFrame")
            text_tab.columnconfigure(0, weight=1)
            text_tab.rowconfigure(1, weight=1)
            ttk.Label(text_tab, text="Type the phrase to transform into audio.", style="Card.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 6))
            self.text_widget = tk.Text(text_tab, height=10, wrap="word", font=("SF Pro Text", 12))
            self.text_widget.insert("1.0", "Hello from MBROLA")
            self.text_widget.grid(row=1, column=0, sticky="nsew")
            text_scroll = ttk.Scrollbar(text_tab, orient="vertical", command=self.text_widget.yview)
            text_scroll.grid(row=1, column=1, sticky="ns")
            self.text_widget.configure(
                yscrollcommand=text_scroll.set,
                background=self.card_bg,
                relief="flat",
                highlightthickness=0,
                borderwidth=0,
                insertbackground="#1c1c1e",
            )

            text_form = ttk.Frame(text_tab, style="CardInner.TFrame")
            text_form.grid(row=2, column=0, sticky="ew", pady=(12, 0))
            text_form.columnconfigure(1, weight=1)
            ttk.Label(text_form, text="eSpeak voice", style="Card.TLabel").grid(row=0, column=0, sticky="w")
            self.espeak_voice_entry = ttk.Entry(text_form, textvariable=self.espeak_voice_var)
            self.espeak_voice_entry.grid(row=0, column=1, sticky="ew", padx=(0, 12))

            ttk.Label(text_form, text="eSpeak binary", style="Card.TLabel").grid(row=1, column=0, sticky="w", pady=(8, 0))
            self.espeak_bin_entry = ttk.Entry(text_form, textvariable=self.espeak_bin_var)
            self.espeak_bin_entry.grid(row=1, column=1, sticky="ew", padx=(0, 12))
            ttk.Button(text_form, text="Browse…", command=self._browse_espeak_bin, style="Secondary.TButton").grid(row=1, column=2, sticky="ew")

            ttk.Label(text_form, text="Extra arguments", style="Card.TLabel").grid(row=2, column=0, sticky="w", pady=(8, 0))
            self.espeak_args_entry = ttk.Entry(text_form, textvariable=self.espeak_args_var)
            self.espeak_args_entry.grid(row=2, column=1, columnspan=2, sticky="ew")
            ttk.Label(text_form, text="Space-separated flags forwarded to espeak-ng.", style="Caption.TLabel").grid(row=3, column=0, columnspan=3, sticky="w", pady=(4, 0))

            pho_tab = ttk.Frame(self.input_notebook, padding=12, style="CardInner.TFrame")
            pho_tab.columnconfigure(1, weight=1)
            ttk.Label(pho_tab, text="Use an existing .pho file.", style="Card.TLabel").grid(row=0, column=0, columnspan=2, sticky="w")
            self.pho_path_entry = ttk.Entry(pho_tab, textvariable=self.pho_path_var)
            self.pho_path_entry.grid(row=1, column=0, sticky="ew", pady=(8, 0), padx=(0, 12))
            ttk.Button(pho_tab, text="Browse…", command=self._browse_pho_file, style="Secondary.TButton").grid(row=1, column=1, sticky="ew", pady=(8, 0))
            ttk.Label(pho_tab, text="MBROLA expects UTF-8 encoded phonemes.", style="Caption.TLabel").grid(row=2, column=0, columnspan=2, sticky="w", pady=(4, 0))

            demo_tab = ttk.Frame(self.input_notebook, padding=12, style="CardInner.TFrame")
            demo_tab.columnconfigure(1, weight=1)
            ttk.Label(demo_tab, text="Preview with a friendly greeting.", style="Card.TLabel").grid(row=0, column=0, columnspan=2, sticky="w")
            ttk.Label(demo_tab, text="Phrase", style="Card.TLabel").grid(row=1, column=0, sticky="w", pady=(8, 0))
            self.demo_text_entry = ttk.Entry(demo_tab, textvariable=self.demo_text_var)
            self.demo_text_entry.grid(row=1, column=1, sticky="ew", pady=(8, 0))
            ttk.Label(demo_tab, text="eSpeak voice", style="Card.TLabel").grid(row=2, column=0, sticky="w", pady=(8, 0))
            self.demo_voice_entry = ttk.Entry(demo_tab, textvariable=self.espeak_voice_var)
            self.demo_voice_entry.grid(row=2, column=1, sticky="ew", pady=(8, 0))
            ttk.Label(demo_tab, text="Use voices like mb-en1 or mb-fr1.", style="Caption.TLabel").grid(row=3, column=0, columnspan=2, sticky="w", pady=(4, 0))

            self.input_notebook.add(text_tab, text="Text")
            self.input_notebook.add(pho_tab, text="Phonemes")
            self.input_notebook.add(demo_tab, text="Demo")

            self._tab_modes = {text_tab: "text", pho_tab: "pho", demo_tab: "demo"}
            self.input_notebook.bind("<<NotebookTabChanged>>", self._on_tab_change)

            ttk.Separator(container).grid(row=4, column=0, sticky="ew", pady=(24, 0))

            signal_card = ttk.Frame(container, padding=18, style="Card.TFrame")
            signal_card.grid(row=5, column=0, sticky="ew", pady=(24, 0))
            signal_card.columnconfigure(1, weight=1)
            ttk.Label(signal_card, text="MBROLA parameters", style="CardHeading.TLabel").grid(row=0, column=0, columnspan=3, sticky="w")

            signal_fields = (
                ("Volume (−v)", self.volume_var, "Boost or reduce amplitude."),
                ("Time ratio (−t)", self.time_ratio_var, "Stretch the duration."),
                ("Frequency (−f)", self.freq_ratio_var, "Shift the pitch contour."),
                ("Comment char (−c)", self.comment_char_var, "Allow custom line comments."),
            )
            for idx, (label, var, caption) in enumerate(signal_fields, start=1):
                ttk.Label(signal_card, text=label, style="Card.TLabel").grid(row=idx, column=0, sticky="w", pady=(8 if idx > 1 else 12, 0))
                ttk.Entry(signal_card, textvariable=var, width=12).grid(row=idx, column=1, sticky="w")
                ttk.Label(signal_card, text=caption, style="Caption.TLabel").grid(row=idx, column=2, sticky="w", padx=(12, 0))

            extras_card = ttk.Frame(container, padding=18, style="Card.TFrame")
            extras_card.grid(row=6, column=0, sticky="ew", pady=(24, 0))
            extras_card.columnconfigure(1, weight=1)
            ttk.Label(extras_card, text="Finishing touches", style="CardHeading.TLabel").grid(row=0, column=0, columnspan=3, sticky="w")
            ttk.Checkbutton(extras_card, text="Ignore MBROLA warning checks", variable=self.ignore_errors_var).grid(row=1, column=0, columnspan=2, sticky="w", pady=(12, 0))
            ttk.Checkbutton(extras_card, text="Play after rendering", variable=self.play_after_var).grid(row=2, column=0, columnspan=2, sticky="w", pady=(8, 0))

            ttk.Label(extras_card, text="Dump generated .pho", style="Card.TLabel").grid(row=3, column=0, sticky="w", pady=(12, 0))
            self.dump_pho_entry = ttk.Entry(extras_card, textvariable=self.dump_pho_var)
            self.dump_pho_entry.grid(row=3, column=1, sticky="ew", padx=(0, 12), pady=(12, 0))
            ttk.Button(extras_card, text="Save…", command=self._browse_dump_pho, style="Secondary.TButton").grid(row=3, column=2, sticky="ew", pady=(12, 0))
            ttk.Label(extras_card, text="Optional: capture the intermediate phoneme file for later reuse.", style="Caption.TLabel").grid(row=4, column=0, columnspan=3, sticky="w", pady=(6, 0))

            controls = ttk.Frame(container, style="Surface.TFrame")
            controls.grid(row=7, column=0, sticky="ew", pady=(24, 12))
            controls.columnconfigure(1, weight=1)
            self.synth_btn = ttk.Button(controls, text="Render Audio", style="Accent.TButton", command=self._start_synthesis)
            self.synth_btn.grid(row=0, column=0, padx=(0, 12))
            self.play_btn = ttk.Button(controls, text="Play Last Output", style="Secondary.TButton", command=self._play_latest)
            self.play_btn.grid(row=0, column=1, sticky="w")
            ttk.Button(controls, text="Close", style="Secondary.TButton", command=self.destroy).grid(row=0, column=2, padx=(12, 0))

            ttk.Label(container, textvariable=self.status_var, style="Status.TLabel", anchor="w").grid(row=8, column=0, sticky="ew")

            self._espeak_inputs = [
                self.espeak_voice_entry,
                self.espeak_bin_entry,
                self.espeak_args_entry,
                self.demo_voice_entry,
            ]

        # ---- utilities ----------------------------------------------------------
        def _browse_voice_file(self) -> None:
            path = filedialog.askopenfilename(title="Select MBROLA voice file")
            if path:
                self.voice_var.set(path)

        def _browse_voice_dir(self) -> None:
            path = filedialog.askdirectory(title="Select MBROLA voice directory")
            if path:
                self.voice_var.set(path)

        def _browse_mbrola_bin(self) -> None:
            path = filedialog.askopenfilename(title="Select mbrola executable")
            if path:
                self.mbrola_bin_var.set(path)

        def _browse_espeak_bin(self) -> None:
            path = filedialog.askopenfilename(title="Select espeak-ng executable")
            if path:
                self.espeak_bin_var.set(path)

        def _browse_output(self) -> None:
            path = filedialog.asksaveasfilename(title="Choose output audio file", defaultextension=".wav")
            if path:
                self.out_var.set(path)

        def _browse_pho_file(self) -> None:
            path = filedialog.askopenfilename(title="Select .pho file", filetypes=[("MBROLA phoneme", ".pho"), ("All files", "*.*")])
            if path:
                self.pho_path_var.set(path)

        def _browse_dump_pho(self) -> None:
            path = filedialog.asksaveasfilename(title="Dump generated .pho", defaultextension=".pho")
            if path:
                self.dump_pho_var.set(path)

        def _set_running(self, running: bool) -> None:
            state = "disabled" if running else "normal"
            self.synth_btn.configure(state=state)
            self.play_btn.configure(state=("disabled" if running or not self.last_output else "normal"))
            if running:
                self.status_var.set("Synthesizing...")
            elif not self.last_output:
                self.status_var.set("Ready to create audio.")

        def _on_tab_change(self, _event=None) -> None:
            current = self.input_notebook.nametowidget(self.input_notebook.select())
            for frame, mode in self._tab_modes.items():
                if frame is current:
                    self.mode_var.set(mode)
                    break
            self._update_mode_state()

        def _update_mode_state(self) -> None:
            mode = self.mode_var.get()
            espeak_state = "normal" if mode in {"text", "demo"} else "disabled"
            for widget in self._espeak_inputs:
                try:
                    widget.configure(state=espeak_state)
                except tk.TclError:
                    pass

            demo_state = "normal" if mode == "demo" else "disabled"
            try:
                self.demo_text_entry.configure(state=demo_state)
            except tk.TclError:
                pass

        def _safe_float(self, value: str) -> Optional[float]:
            value = value.strip()
            if not value:
                return None
            try:
                return float(value)
            except ValueError:
                raise MBROLAError(f"Cannot convert '{value}' to float")

        def _start_synthesis(self) -> None:
            voice = self.voice_var.get().strip()
            out_path = self.out_var.get().strip()
            mode = self.mode_var.get()

            if not voice:
                messagebox.showerror("Add a voice", "Choose a MBROLA voice to continue.")
                return
            if not out_path:
                messagebox.showerror("Choose a destination", "Pick where you'd like the audio to be saved.")
                return

            espeak_voice = self.espeak_voice_var.get().strip()
            espeak_bin = self.espeak_bin_var.get().strip() or None
            espeak_args_raw = self.espeak_args_var.get().strip()
            espeak_args: Optional[Sequence[str]] = shlex.split(espeak_args_raw) if espeak_args_raw else None

            dump_pho = self.dump_pho_var.get().strip() or None
            comment_char = self.comment_char_var.get().strip() or None
            if comment_char and len(comment_char) > 1:
                comment_char = comment_char[0]

            try:
                volume = self._safe_float(self.volume_var.get())
                time_ratio = self._safe_float(self.time_ratio_var.get())
                freq_ratio = self._safe_float(self.freq_ratio_var.get())
            except MBROLAError as exc:
                messagebox.showerror("Check the numbers", f"{exc}. Try a plain number like 1.2")
                return

            payload = {
                "voice": voice,
                "mbrola_bin": self.mbrola_bin_var.get().strip() or None,
                "out_path": out_path,
                "mode": mode,
                "volume": volume,
                "time_ratio": time_ratio,
                "freq_ratio": freq_ratio,
                "ignore_errors": self.ignore_errors_var.get(),
                "comment_char": comment_char,
                "dump_pho": dump_pho,
                "play_after": self.play_after_var.get(),
                "espeak_voice": espeak_voice,
                "espeak_bin": espeak_bin,
                "espeak_args": espeak_args,
            }

            if mode == "text":
                text_value = self.text_widget.get("1.0", tk.END).strip()
                if not text_value:
                    messagebox.showerror("Add some text", "Type a phrase to render or switch to the phoneme tab.")
                    return
                if not espeak_voice:
                    messagebox.showerror("Pick an eSpeak voice", "Use a voice such as mb-en1 so MBROLA knows how to speak it.")
                    return
                payload["text"] = text_value
            elif mode == "pho":
                pho_path = self.pho_path_var.get().strip()
                if not pho_path:
                    messagebox.showerror("Select a phoneme file", "Choose the .pho file you'd like MBROLA to render.")
                    return
                payload["pho_path"] = pho_path
            else:  # demo
                demo_text = self.demo_text_var.get().strip() or "Hello from MBROLA"
                payload["demo_text"] = demo_text
                payload["espeak_voice"] = espeak_voice or "mb-en1"

            self.status_var.set("Synthesizing...")
            self._set_running(True)
            worker = threading.Thread(target=self._run_synthesis, args=(payload,), daemon=True)
            worker.start()

        def _run_synthesis(self, payload: dict[str, object]) -> None:
            try:
                mbrola_bin = payload.get("mbrola_bin") or None
                tts = MBROLA(voice_path=payload["voice"], mbrola_bin=mbrola_bin)  # type: ignore[index]

                mode = payload["mode"]  # type: ignore[index]
                pho_text: Optional[str] = None

                if mode == "pho":
                    pho_path = Path(payload["pho_path"])  # type: ignore[index]
                    pho_text = pho_path.read_text(encoding="utf-8")
                elif mode == "text":
                    text_value = payload["text"]  # type: ignore[index]
                    pho_text = tts.generate_pho(
                        text_value,
                        espeak_voice=payload["espeak_voice"],  # type: ignore[index]
                        espeak_bin=payload.get("espeak_bin"),
                        espeak_extra_args=payload.get("espeak_args"),
                    )
                else:  # demo
                    demo_text = payload["demo_text"]  # type: ignore[index]
                    pho_text = tts.generate_pho(
                        demo_text,
                        espeak_voice=payload["espeak_voice"],  # type: ignore[index]
                        espeak_bin=payload.get("espeak_bin"),
                        espeak_extra_args=payload.get("espeak_args"),
                    )

                if payload.get("dump_pho") and pho_text is not None:
                    dump_path = Path(payload["dump_pho"])  # type: ignore[index]
                    dump_path.write_text(pho_text, encoding="utf-8")

                synth_kwargs = {
                    "volume": payload.get("volume"),
                    "time_ratio": payload.get("time_ratio"),
                    "freq_ratio": payload.get("freq_ratio"),
                    "comment_char": payload.get("comment_char"),
                }
                synth_kwargs = {k: v for k, v in synth_kwargs.items() if v is not None}
                out_path = tts.synthesize_pho(
                    pho_text or "",
                    payload["out_path"],  # type: ignore[index]
                    ignore_errors=bool(payload.get("ignore_errors", True)),
                    **synth_kwargs,
                )

                play_after = bool(payload.get("play_after"))
                play_result: Optional[bool] = None
                if play_after:
                    play_result = play_audio(out_path)

                self.task_queue.put(("success", out_path, play_after, play_result))
            except Exception as exc:  # pragma: no cover - GUI surface
                self.task_queue.put(("error", str(exc)))

        def _poll_queue(self) -> None:
            try:
                message = self.task_queue.get_nowait()
            except queue.Empty:
                self.after(150, self._poll_queue)
                return

            kind = message[0]
            if kind == "success":
                _, out_path, play_after, play_result = message
                self.last_output = str(out_path)
                self.status_var.set(f"Saved to {out_path}")
                self._set_running(False)
                messagebox.showinfo("Audio exported", f"Saved to {out_path}")
                if play_after and play_result is False:
                    messagebox.showwarning(
                        "Playback unavailable",
                        "The file is ready, but playback wasn't possible. Install ffplay/aplay/paplay/afplay or SoX 'play' to preview inside the app.",
                    )
            else:
                _, error_msg = message
                self.status_var.set(f"Error: {error_msg}")
                self._set_running(False)
                messagebox.showerror("Couldn't complete the render", error_msg)

            self.after(150, self._poll_queue)

        def _play_latest(self) -> None:
            if not self.last_output:
                messagebox.showinfo("Nothing to play yet", "Render an export first, then try playing it from here.")
                return
            ok = play_audio(self.last_output)
            if not ok:
                messagebox.showwarning(
                    "Playback unavailable",
                    "The file is ready, but playback wasn't possible. Install ffplay/aplay/paplay/afplay or SoX 'play' to preview inside the app.",
                )

    app = MBROLAGUI()
    app.mainloop()

# ---------------- CLI -----------------

def _build_arg_parser():
    import argparse

    p = argparse.ArgumentParser(description="MBROLA Python interface (wrapper around the 'mbrola' binary)")
    p.add_argument("--gui", action="store_true", help="Launch a basic Tkinter GUI (no other arguments required)")
    p.add_argument("--voice", help="Path to MBROLA voice file or its directory (e.g. /usr/share/mbrola/en1/en1)")
    p.add_argument("--out", help="Output audio path (.wav/.au/.aiff/.raw based on extension)")

    g = p.add_mutually_exclusive_group()
    g.add_argument("--text", help="Input text. Use with --espeak-voice (requires espeak-ng)")
    g.add_argument("--pho-file", help="Path to a .pho input file")
    g.add_argument("--demo", action="store_true", help="Run a quick demo: generate a small .pho from text and play it")

    p.add_argument("--mbrola-bin", default=None, help="Path to mbrola executable (defaults to PATH)")

    # espeak options
    p.add_argument("--espeak-voice", default=None, help="espeak-ng voice like 'mb-en1', 'mb-fr1' (required with --text or for --demo; defaults to mb-en1 for --demo)")
    p.add_argument("--espeak-bin", default=None, help="Path to espeak-ng executable (defaults to PATH)")
    p.add_argument("--espeak-arg", action="append", default=[], help="Extra espeak-ng arg(s), may be repeated, e.g. --espeak-arg -s --espeak-arg 160")

    # mbrola signal shaping
    p.add_argument("--volume", type=float, default=None, help="MBROLA volume ratio (-v)")
    p.add_argument("--time", dest="time_ratio", type=float, default=None, help="MBROLA time ratio (-t)")
    p.add_argument("--freq", dest="freq_ratio", type=float, default=None, help="MBROLA frequency ratio (-f)")
    p.add_argument("--no-ignore-errors", dest="ignore_errors", action="store_false", help="Do not pass -e to MBROLA")

    # extras
    p.add_argument("--dump-pho", default=None, help="If set and using --text or --demo, write the generated .pho here as well")
    p.add_argument("--play", action="store_true", help="Attempt to play the resulting audio (tries ffplay/aplay/paplay/afplay/play)")
    p.add_argument("--demo-text", default="Hello from MBROLA", help="Override demo text (used with --demo)")

    return p


def main(argv: Optional[Sequence[str]] = None) -> int:
    import argparse

    parser = _build_arg_parser()
    args = parser.parse_args(argv)

    if args.gui:
        launch_gui(
            initial_voice=args.voice,
            initial_mbrola_bin=args.mbrola_bin,
            initial_espeak_voice=args.espeak_voice,
            initial_out=args.out,
        )
        return 0

    if not args.voice:
        parser.error("--voice is required unless --gui is used")
    if not args.out:
        parser.error("--out is required unless --gui is used")
    if not (args.text or args.pho_file or args.demo):
        parser.error("One of --text, --pho-file or --demo is required unless --gui is used")

    try:
        tts = MBROLA(voice_path=args.voice, mbrola_bin=args.mbrola_bin)

        if args.demo:
            v = args.espeak_voice or "mb-en1"
            pho = tts.generate_pho(args.demo_text, espeak_voice=v, espeak_bin=args.espeak_bin, espeak_extra_args=args.espeak_arg)
            if args.dump_pho:
                Path(args.dump_pho).write_text(pho, encoding="utf-8")
            tts.synthesize_pho(
                pho,
                out_path=args.out,
                volume=args.volume,
                time_ratio=args.time_ratio,
                freq_ratio=args.freq_ratio,
                ignore_errors=args.ignore_errors,
            )
        elif args.text is not None:
            if not args.espeak_voice:
                raise MBROLAError("--espeak-voice is required when using --text")
            pho = tts.generate_pho(
                args.text,
                espeak_voice=args.espeak_voice,
                espeak_bin=args.espeak_bin,
                espeak_extra_args=args.espeak_arg,
            )
            if args.dump_pho:
                Path(args.dump_pho).write_text(pho, encoding="utf-8")
            tts.synthesize_pho(
                pho,
                out_path=args.out,
                volume=args.volume,
                time_ratio=args.time_ratio,
                freq_ratio=args.freq_ratio,
                ignore_errors=args.ignore_errors,
            )
        else:
            pho = Path(args.pho_file).read_text(encoding="utf-8")
            tts.synthesize_pho(
                pho,
                out_path=args.out,
                volume=args.volume,
                time_ratio=args.time_ratio,
                freq_ratio=args.freq_ratio,
                ignore_errors=args.ignore_errors,
            )

        out_abs = str(Path(args.out).resolve())
        print(f"Wrote: {out_abs}")
        if args.play:
            ok = play_audio(out_abs)
            if not ok:
                print("(Could not auto-play; install ffplay/aplay/paplay/afplay or SoX 'play')")
        return 0
    except MBROLAError as e:
        print(f"Error: {e}")
        return 2


if __name__ == "__main__":
    raise SystemExit(main())
