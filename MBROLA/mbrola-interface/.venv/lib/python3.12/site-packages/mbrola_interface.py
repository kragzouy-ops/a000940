"""
MBROLA Python interface — zero‑dependency wrapper (+ demo)

Features
- Call the `mbrola` binary from Python with a given voice database
- Accept raw .pho content or generate it from text via espeak‑ng (optional)
- Save directly to .wav / .au / .aiff depending on output filename extension
- Control volume, time and pitch ratios (-v, -t, -f)
- Read voice metadata (mbrola -i)
- CLI with --demo, --play and --dump-pho

Requirements
- MBROLA installed and in PATH (or supply absolute path)
- At least one MBROLA voice database (e.g. /usr/share/mbrola/en1/en1)
- Optional: espeak‑ng in PATH to turn text → MBROLA phonemes

Usage
-----
Basic (from text using espeak‑ng):
    from mbrola_interface import MBROLA
    tts = MBROLA(voice_path="/usr/share/mbrola/en1/en1")
    tts.synthesize_text("Hello world", out_path="hello.wav", espeak_voice="mb-en1")

From raw .pho content (string):
    pho = """
    _ 150
    h 70
    @ 60
    l 80
    o 120  0 110  60 110
    w 80
    3:U 140  0 110  80 100
    r 60
    l 80
    d 80
    _ 150
    """.strip()
    MBROLA(voice_path="/usr/share/mbrola/en1/en1").synthesize_pho(pho, out_path="hello.wav")

Command‑line:
    python mbrola_interface.py \
        --voice /usr/share/mbrola/en1/en1 \
        --text "Hello from MBROLA" \
        --out hello.wav \
        --espeak-voice mb-en1
"""
from __future__ import annotations

import os
import shlex
import subprocess
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import Optional, Sequence


class MBROLAError(RuntimeError):
    pass


def _which(prog: str) -> Optional[str]:
    """Return absolute path of executable in PATH (or None)."""
    from shutil import which
    return which(prog)


def _ensure_executable(path: Optional[str], fallback: str) -> str:
    """Return a valid executable path, checking PATH if needed."""
    if path:
        p = Path(path)
        if p.is_file() and os.access(p, os.X_OK):
            return str(p)
        raise MBROLAError(f"Executable not found or not executable: {path}")
    w = _which(fallback)
    if not w:
        raise MBROLAError(
            f"Required executable '{fallback}' not found in PATH. Set explicit path or adjust PATH.")
    return w


def _resolve_voice_file(voice_path: str | os.PathLike[str]) -> str:
    """Return the path to the MBROLA voice *file*.

    The argument may be a file like '/usr/share/mbrola/en1/en1' or a directory
    like '/usr/share/mbrola/en1'. If a directory is given, we try sensible
    candidates inside it (same basename as directory, or a single file without
    extension).
    """
    p = Path(voice_path)
    if p.is_file():
        return str(p)
    if not p.exists():
        raise MBROLAError(f"Voice path does not exist: {voice_path}")
    if p.is_dir():
        # candidate 1: file with same basename as directory
        cand = p / p.name
        if cand.exists() and cand.is_file():
            return str(cand)
        # candidate 2: first regular file with no extension
        noext = [f for f in p.iterdir() if f.is_file() and f.suffix == ""]
        if len(noext) == 1:
            return str(noext[0])
        # candidate 3: any regular file (fall back to longest name)
        files = [f for f in p.iterdir() if f.is_file()]
        if files:
            files.sort(key=lambda x: len(x.name), reverse=True)
            return str(files[0])
    raise MBROLAError(f"Could not locate voice file inside: {voice_path}")


def play_audio(path: str) -> bool:
    """Best‑effort audio playback using common CLIs; returns True if one worked.
    Tries: ffplay (ffmpeg), aplay (ALSA), paplay (PulseAudio), afplay (macOS), play (SoX).
    """
    candidates = [
        ("ffplay", ["-autoexit", "-nodisp"]),
        ("aplay", []),
        ("paplay", []),
        ("afplay", []),
        ("play", [])
    ]
    for prog, extra in candidates:
        exe = _which(prog)
        if exe:
            try:
                subprocess.run([exe] + extra + [path], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                return True
            except Exception:
                continue
    return False


@dataclass
class MBROLA:
    voice_path: str
    mbrola_bin: Optional[str] = None

    def __post_init__(self) -> None:
        self.mbrola_bin = _ensure_executable(self.mbrola_bin, "mbrola")
        self.voice_file = _resolve_voice_file(self.voice_path)

    # --- helpers -----------------------------------------------------
    def generate_pho(
        self,
        text: str,
        *,
        espeak_voice: str,
        espeak_bin: Optional[str] = None,
        espeak_extra_args: Optional[Sequence[str]] = None,
    ) -> str:
        """Return MBROLA .pho string generated by espeak‑ng for *text*."""
        espeak = _ensure_executable(espeak_bin, "espeak-ng")
        cmd = [espeak, "-q", "--pho", "-v", espeak_voice]
        if espeak_extra_args:
            cmd += list(espeak_extra_args)
        try:
            gen = subprocess.run(
                cmd,
                input=text.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=False,
            )
        except FileNotFoundError as e:
            raise MBROLAError(f"Failed to execute espeak-ng: {e}") from e
        if gen.returncode != 0:
            raise MBROLAError(
                "espeak-ng failed (exit code %s) with command:\n%s\nStderr:\n%s"
                % (gen.returncode, " ".join(shlex.quote(c) for c in cmd), gen.stderr.decode(errors="ignore"))
            )
        pho = gen.stdout.decode("utf-8", errors="ignore")
        if not pho.strip():
            raise MBROLAError("espeak-ng produced empty .pho stream")
        return pho

    # --- public API -----------------------------------------------------
    def synthesize_pho(
        self,
        pho_text: str,
        out_path: str | os.PathLike[str],
        *,
        volume: float | None = None,
        time_ratio: float | None = None,
        freq_ratio: float | None = None,
        ignore_errors: bool = True,
        comment_char: Optional[str] = None,
    ) -> str:
        """Synthesize audio from MBROLA .pho content and write it to *out_path*.

        The output format is chosen from the filename extension ('.wav', '.au', '.aiff', '.raw').
        Returns the absolute path to the written file.
        """
        out_path = str(Path(out_path).expanduser().resolve())
        cmd = [self.mbrola_bin]
        if ignore_errors:
            cmd.append("-e")
        if comment_char:
            cmd += ["-c", comment_char]
        if volume is not None:
            cmd += ["-v", str(float(volume))]
        if freq_ratio is not None:
            cmd += ["-f", str(float(freq_ratio))]
        if time_ratio is not None:
            cmd += ["-t", str(float(time_ratio))]
        cmd += [self.voice_file, "-", out_path]

        # Use stdin to supply .pho content
        try:
            proc = subprocess.run(
                cmd,
                input=pho_text.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=False,
            )
        except FileNotFoundError as e:
            raise MBROLAError(f"Failed to execute mbrola: {e}") from e

        if proc.returncode != 0:
            raise MBROLAError(
                "MBROLA failed (exit code %s) with command:\n%s\nStderr:\n%s"
                % (proc.returncode, " ".join(shlex.quote(c) for c in cmd), proc.stderr.decode(errors="ignore"))
            )
        return out_path

    def synthesize_text(
        self,
        text: str,
        out_path: str | os.PathLike[str],
        *,
        espeak_voice: str,
        espeak_bin: Optional[str] = None,
        espeak_extra_args: Optional[Sequence[str]] = None,
        **synth_kwargs,
    ) -> str:
        """Generate MBROLA .pho with espeak‑ng and synthesize to *out_path*."""
        pho = self.generate_pho(
            text,
            espeak_voice=espeak_voice,
            espeak_bin=espeak_bin,
            espeak_extra_args=espeak_extra_args,
        )
        return self.synthesize_pho(pho, out_path, **synth_kwargs)

    def synthesize_pho_to_bytes(
        self,
        pho_text: str,
        *,
        suffix: str = ".wav",
        **synth_kwargs,
    ) -> bytes:
        """Synthesize to a temporary file and return its bytes.
        Useful when you want a WAV/AIFF payload in memory.
        """
        with tempfile.TemporaryDirectory() as td:
            out = Path(td) / ("mbrola_out" + suffix)
            self.synthesize_pho(pho_text, out, **synth_kwargs)
            return Path(out).read_bytes()

    def voice_info(self) -> str:
        """Return `mbrola -i <voice>` output (if available)."""
        cmd = [self.mbrola_bin, "-i", self.voice_file, "-", "-"]
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=False)
        return proc.stdout.decode(errors="ignore")


# ---------------- CLI -----------------

def _build_arg_parser():
    import argparse

    p = argparse.ArgumentParser(description="MBROLA Python interface (wrapper around the 'mbrola' binary)")
    p.add_argument("--voice", required=True, help="Path to MBROLA voice file or its directory (e.g. /usr/share/mbrola/en1/en1)")
    p.add_argument("--out", required=True, help="Output audio path (.wav/.au/.aiff/.raw based on extension)")

    g = p.add_mutually_exclusive_group(required=True)
    g.add_argument("--text", help="Input text. Use with --espeak-voice (requires espeak-ng)")
    g.add_argument("--pho-file", help="Path to a .pho input file")
    g.add_argument("--demo", action="store_true", help="Run a quick demo: generate a small .pho from text and play it")

    p.add_argument("--mbrola-bin", default=None, help="Path to mbrola executable (defaults to PATH)")

    # espeak options
    p.add_argument("--espeak-voice", default=None, help="espeak-ng voice like 'mb-en1', 'mb-fr1' (required with --text or for --demo; defaults to mb-en1 for --demo)")
    p.add_argument("--espeak-bin", default=None, help="Path to espeak-ng executable (defaults to PATH)")
    p.add_argument("--espeak-arg", action="append", default=[], help="Extra espeak-ng arg(s), may be repeated, e.g. --espeak-arg -s --espeak-arg 160")

    # mbrola signal shaping
    p.add_argument("--volume", type=float, default=None, help="MBROLA volume ratio (-v)")
    p.add_argument("--time", dest="time_ratio", type=float, default=None, help="MBROLA time ratio (-t)")
    p.add_argument("--freq", dest="freq_ratio", type=float, default=None, help="MBROLA frequency ratio (-f)")
    p.add_argument("--no-ignore-errors", dest="ignore_errors", action="store_false", help="Do not pass -e to MBROLA")

    # extras
    p.add_argument("--dump-pho", default=None, help="If set and using --text or --demo, write the generated .pho here as well")
    p.add_argument("--play", action="store_true", help="Attempt to play the resulting audio (tries ffplay/aplay/paplay/afplay/play)")
    p.add_argument("--demo-text", default="Hello from MBROLA", help="Override demo text (used with --demo)")

    return p


def main(argv: Optional[Sequence[str]] = None) -> int:
    import argparse
    args = _build_arg_parser().parse_args(argv)

    try:
        tts = MBROLA(voice_path=args.voice, mbrola_bin=args.mbrola_bin)

        if args.demo:
            v = args.espeak_voice or "mb-en1"
            pho = tts.generate_pho(args.demo_text, espeak_voice=v, espeak_bin=args.espeak_bin, espeak_extra_args=args.espeak_arg)
            if args.dump_pho:
                Path(args.dump_pho).write_text(pho, encoding="utf-8")
            tts.synthesize_pho(
                pho,
                out_path=args.out,
                volume=args.volume,
                time_ratio=args.time_ratio,
                freq_ratio=args.freq_ratio,
                ignore_errors=args.ignore_errors,
            )
        elif args.text is not None:
            if not args.espeak_voice:
                raise MBROLAError("--espeak-voice is required when using --text")
            pho = tts.generate_pho(
                args.text,
                espeak_voice=args.espeak_voice,
                espeak_bin=args.espeak_bin,
                espeak_extra_args=args.espeak_arg,
            )
            if args.dump_pho:
                Path(args.dump_pho).write_text(pho, encoding="utf-8")
            tts.synthesize_pho(
                pho,
                out_path=args.out,
                volume=args.volume,
                time_ratio=args.time_ratio,
                freq_ratio=args.freq_ratio,
                ignore_errors=args.ignore_errors,
            )
        else:
            pho = Path(args.pho_file).read_text(encoding="utf-8")
            tts.synthesize_pho(
                pho,
                out_path=args.out,
                volume=args.volume,
                time_ratio=args.time_ratio,
                freq_ratio=args.freq_ratio,
                ignore_errors=args.ignore_errors,
            )

        out_abs = str(Path(args.out).resolve())
        print(f"Wrote: {out_abs}")
        if args.play:
            ok = play_audio(out_abs)
            if not ok:
                print("(Could not auto-play; install ffplay/aplay/paplay/afplay or SoX 'play')")
        return 0
    except MBROLAError as e:
        print(f"Error: {e}")
        return 2


if __name__ == "__main__":
    raise SystemExit(main())
